import {
  Connection,
  PublicKey,
  Transaction,
  TransactionInstruction,
  Keypair,
  Commitment,
  ConnectionConfig,
  TransactionSignature,
  ConfirmOptions,
  SendOptions,
  SignatureStatus,
  RpcResponseAndContext,
  AccountInfo,
  ParsedAccountData,
  GetProgramAccountsFilter,
  Blockhash,
  FeeCalculator,
} from '@solana/web3.js';
import {
  TOKEN_PROGRAM_ID,
  ASSOCIATED_TOKEN_PROGRAM_ID,
  getAssociatedTokenAddress,
  createAssociatedTokenAccountInstruction,
  getAccount,
  TokenAccountNotFoundError,
} from '@solana/spl-token';
import { AnchorProvider, Program, Idl, BN, utils, web3 } from '@coral-xyz/anchor';
import { Buffer } from 'buffer';

// Import program types (these would be generated by Anchor)
import { Events } from '../target/types/events';
import { TicketNft } from '../target/types/ticket_nft';
import { Marketplace } from '../target/types/marketplace';
import { ContentAccess } from '../target/types/content_access';
import { Staking } from '../target/types/staking';

// Import IDLs
import EventsIDL from '../target/idl/events.json';
import TicketNftIDL from '../target/idl/ticket_nft.json';
import MarketplaceIDL from '../target/idl/marketplace.json';
import ContentAccessIDL from '../target/idl/content_access.json';
import StakingIDL from '../target/idl/staking.json';

// Wallet adapter types
interface WalletAdapter {
  publicKey: PublicKey | null;
  connected: boolean;
  connecting: boolean;
  disconnecting: boolean;
  connect(): Promise<void>;
  disconnect(): Promise<void>;
  signTransaction(transaction: Transaction): Promise<Transaction>;
  signAllTransactions(transactions: Transaction[]): Promise<Transaction[]>;
  signMessage?(message: Uint8Array): Promise<Uint8Array>;
}

// SDK Configuration
export interface SolanaClientConfig {
  network: 'mainnet-beta' | 'testnet' | 'devnet' | 'localnet';
  commitment?: Commitment;
  confirmOptions?: ConfirmOptions;
  wsEndpoint?: string;
  httpHeaders?: Record<string, string>;
  programIds?: {
    events?: PublicKey;
    ticketNft?: PublicKey;
    marketplace?: PublicKey;
    contentAccess?: PublicKey;
    staking?: PublicKey;
  };
}

// Transaction result type
export interface TransactionResult {
  signature: TransactionSignature;
  confirmations: number;
  slot: number;
  err: any | null;
}

// Subscription types
export type AccountChangeCallback<T> = (data: T, context: web3.Context) => void;
export type ErrorCallback = (error: Error) => void;

export interface Subscription {
  id: number;
  unsubscribe: () => void;
}

// Program-specific types
export interface EventData {
  eventId: string;
  name: string;
  startTime: BN;
  endTime: BN;
  venue: string;
  totalTickets: BN;
  ticketsSold: BN;
  ticketPrice: BN;
  isActive: boolean;
}

export interface TicketData {
  ticketId: string;
  eventId: string;
  owner: PublicKey;
  tier: number;
  isUsed: boolean;
  purchaseTime: BN;
}

export interface ListingData {
  seller: PublicKey;
  nftMint: PublicKey;
  price: BN | null;
  minBid: BN | null;
  endTime: BN | null;
  highestBidder: PublicKey | null;
  highestBid: BN;
  status: number;
}

// Main SDK Class
export class SolanaClient {
  private connection: Connection;
  private provider: AnchorProvider | null = null;
  private wallet: WalletAdapter | null = null;
  
  // Program instances
  private eventsProgram: Program<Events> | null = null;
  private ticketNftProgram: Program<TicketNft> | null = null;
  private marketplaceProgram: Program<Marketplace> | null = null;
  private contentAccessProgram: Program<ContentAccess> | null = null;
  private stakingProgram: Program<Staking> | null = null;

  // Configuration
  private config: SolanaClientConfig;
  private subscriptions: Map<number, number> = new Map();
  private subscriptionCounter = 0;

  // Retry configuration
  private maxRetries = 3;
  private retryDelay = 1000; // ms

  constructor(config: SolanaClientConfig) {
    this.config = config;
    
    // Initialize connection
    const endpoint = this.getEndpoint(config.network);
    const connectionConfig: ConnectionConfig = {
      commitment: config.commitment || 'confirmed',
      wsEndpoint: config.wsEndpoint,
      httpHeaders: config.httpHeaders,
    };
    
    this.connection = new Connection(endpoint, connectionConfig);
  }

  // Wallet Connection Management
  public async connectWallet(wallet: WalletAdapter): Promise<void> {
    try {
      if (!wallet.connected) {
        await wallet.connect();
      }
      
      this.wallet = wallet;
      
      // Create provider
      this.provider = new AnchorProvider(
        this.connection,
        wallet as any,
        this.config.confirmOptions || {
          commitment: 'confirmed',
          preflightCommitment: 'processed',
        }
      );

      // Initialize programs
      await this.initializePrograms();
    } catch (error) {
      throw new Error(`Failed to connect wallet: ${error.message}`);
    }
  }

  public async disconnectWallet(): Promise<void> {
    if (this.wallet?.connected) {
      await this.wallet.disconnect();
    }
    
    this.wallet = null;
    this.provider = null;
    this.eventsProgram = null;
    this.ticketNftProgram = null;
    this.marketplaceProgram = null;
    this.contentAccessProgram = null;
    this.stakingProgram = null;
  }

  public isWalletConnected(): boolean {
    return this.wallet?.connected || false;
  }

  public getWalletAddress(): PublicKey | null {
    return this.wallet?.publicKey || null;
  }

  // Program Initialization
  private async initializePrograms(): Promise<void> {
    if (!this.provider) {
      throw new Error('Provider not initialized');
    }

    const programIds = this.getProgramIds();

    // Initialize Events program
    if (programIds.events) {
      this.eventsProgram = new Program<Events>(
        EventsIDL as Idl as Events,
        programIds.events,
        this.provider
      );
    }

    // Initialize Ticket NFT program
    if (programIds.ticketNft) {
      this.ticketNftProgram = new Program<TicketNft>(
        TicketNftIDL as Idl as TicketNft,
        programIds.ticketNft,
        this.provider
      );
    }

    // Initialize Marketplace program
    if (programIds.marketplace) {
      this.marketplaceProgram = new Program<Marketplace>(
        MarketplaceIDL as Idl as Marketplace,
        programIds.marketplace,
        this.provider
      );
    }

    // Initialize Content Access program
    if (programIds.contentAccess) {
      this.contentAccessProgram = new Program<ContentAccess>(
        ContentAccessIDL as Idl as ContentAccess,
        programIds.contentAccess,
        this.provider
      );
    }

    // Initialize Staking program
    if (programIds.staking) {
      this.stakingProgram = new Program<Staking>(
        StakingIDL as Idl as Staking,
        programIds.staking,
        this.provider
      );
    }
  }

  // Transaction Building and Signing
  public async buildTransaction(
    instructions: TransactionInstruction[],
    signers?: Keypair[]
  ): Promise<Transaction> {
    const transaction = new Transaction();
    
    // Add instructions
    instructions.forEach(ix => transaction.add(ix));
    
    // Get recent blockhash
    const { blockhash, lastValidBlockHeight } = await this.connection.getLatestBlockhash();
    transaction.recentBlockhash = blockhash;
    transaction.lastValidBlockHeight = lastValidBlockHeight;
    
    // Set fee payer
    if (this.wallet?.publicKey) {
      transaction.feePayer = this.wallet.publicKey;
    }
    
    // Sign with additional signers if provided
    if (signers && signers.length > 0) {
      transaction.sign(...signers);
    }
    
    return transaction;
  }

  public async signTransaction(transaction: Transaction): Promise<Transaction> {
    if (!this.wallet) {
      throw new Error('Wallet not connected');
    }
    
    return await this.wallet.signTransaction(transaction);
  }

  public async signAllTransactions(transactions: Transaction[]): Promise<Transaction[]> {
    if (!this.wallet) {
      throw new Error('Wallet not connected');
    }
    
    return await this.wallet.signAllTransactions(transactions);
  }

  public async sendTransaction(
    transaction: Transaction,
    options?: SendOptions
  ): Promise<TransactionResult> {
    if (!this.wallet) {
      throw new Error('Wallet not connected');
    }

    let attempt = 0;
    let lastError: Error | null = null;

    while (attempt < this.maxRetries) {
      try {
        // Sign transaction
        const signedTx = await this.signTransaction(transaction);
        
        // Send transaction
        const signature = await this.connection.sendRawTransaction(
          signedTx.serialize(),
          options || {
            skipPreflight: false,
            preflightCommitment: 'processed',
          }
        );

        // Confirm transaction
        const result = await this.confirmTransaction(signature);
        
        return {
          signature,
          confirmations: result.value.confirmations || 0,
          slot: result.context.slot,
          err: result.value.err,
        };
      } catch (error) {
        lastError = error;
        attempt++;
        
        if (attempt < this.maxRetries) {
          await this.sleep(this.retryDelay * attempt);
        }
      }
    }

    throw lastError || new Error('Transaction failed after retries');
  }

  public async confirmTransaction(
    signature: TransactionSignature,
    commitment?: Commitment
  ): Promise<RpcResponseAndContext<SignatureStatus>> {
    const startTime = Date.now();
    const timeout = 30000; // 30 seconds

    while (Date.now() - startTime < timeout) {
      const result = await this.connection.getSignatureStatus(signature);
      
      if (result.value?.confirmationStatus === commitment || 
          result.value?.confirmationStatus === 'finalized') {
        return result;
      }
      
      await this.sleep(1000);
    }

    throw new Error('Transaction confirmation timeout');
  }

  // Account Fetching and Parsing
  public async getAccount<T>(
    address: PublicKey,
    program: Program<any>
  ): Promise<T | null> {
    try {
      const account = await program.account[this.getAccountType(program)].fetch(address);
      return account as T;
    } catch (error) {
      if (error.message.includes('Account does not exist')) {
        return null;
      }
      throw error;
    }
  }

  public async getMultipleAccounts<T>(
    addresses: PublicKey[],
    program: Program<any>
  ): Promise<(T | null)[]> {
    const accountType = this.getAccountType(program);
    const accounts = await program.account[accountType].fetchMultiple(addresses);
    return accounts as (T | null)[];
  }

  public async getProgramAccounts<T>(
    program: Program<any>,
    filters?: GetProgramAccountsFilter[]
  ): Promise<Array<{ pubkey: PublicKey; account: T }>> {
    const accountType = this.getAccountType(program);
    const accounts = await program.account[accountType].all(filters);
    
    return accounts.map(acc => ({
      pubkey: acc.publicKey,
      account: acc.account as T,
    }));
  }

  // Events Program Methods
  public get events() {
    if (!this.eventsProgram) {
      throw new Error('Events program not initialized');
    }

    return {
      createEvent: async (
        eventId: string,
        name: string,
        startTime: BN,
        endTime: BN,
        venue: string,
        totalTickets: BN,
        ticketPrice: BN,
        categories: Array<{ name: string; allocation: BN }>
      ): Promise<TransactionResult> => {
        const [eventPda] = PublicKey.findProgramAddressSync(
          [Buffer.from('event'), Buffer.from(eventId)],
          this.eventsProgram!.programId
        );

        const ix = await this.eventsProgram!.methods
          .createEvent(eventId, name, startTime, endTime, venue, totalTickets, ticketPrice, categories)
          .accounts({
            organizer: this.wallet!.publicKey!,
            event: eventPda,
            systemProgram: web3.SystemProgram.programId,
          })
          .instruction();

        const tx = await this.buildTransaction([ix]);
        return await this.sendTransaction(tx);
      },

      updateEvent: async (
        eventId: string,
        name: string | null,
        startTime: BN | null,
        endTime: BN | null,
        venue: string | null
      ): Promise<TransactionResult> => {
        const [eventPda] = PublicKey.findProgramAddressSync(
          [Buffer.from('event'), Buffer.from(eventId)],
          this.eventsProgram!.programId
        );

        const ix = await this.eventsProgram!.methods
          .updateEvent(name, startTime, endTime, venue)
          .accounts({
            organizer: this.wallet!.publicKey!,
            event: eventPda,
          })
          .instruction();

        const tx = await this.buildTransaction([ix]);
        return await this.sendTransaction(tx);
      },

      cancelEvent: async (eventId: string): Promise<TransactionResult> => {
        const [eventPda] = PublicKey.findProgramAddressSync(
          [Buffer.from('event'), Buffer.from(eventId)],
          this.eventsProgram!.programId
        );

        const ix = await this.eventsProgram!.methods
          .cancelEvent()
          .accounts({
            organizer: this.wallet!.publicKey!,
            event: eventPda,
          })
          .instruction();

        const tx = await this.buildTransaction([ix]);
        return await this.sendTransaction(tx);
      },

      getEvent: async (eventId: string): Promise<EventData | null> => {
        const [eventPda] = PublicKey.findProgramAddressSync(
          [Buffer.from('event'), Buffer.from(eventId)],
          this.eventsProgram!.programId
        );

        return await this.getAccount<EventData>(eventPda, this.eventsProgram!);
      },

      getAllEvents: async (): Promise<Array<{ pubkey: PublicKey; account: EventData }>> => {
        return await this.getProgramAccounts<EventData>(this.eventsProgram!);
      },

      getOrganizerEvents: async (organizer: PublicKey): Promise<Array<{ pubkey: PublicKey; account: EventData }>> => {
        const filters = [
          {
            memcmp: {
              offset: 8, // Discriminator
              bytes: organizer.toBase58(),
            },
          },
        ];

        return await this.getProgramAccounts<EventData>(this.eventsProgram!, filters);
      },
    };
  }

  // Ticket NFT Program Methods
  public get tickets() {
    if (!this.ticketNftProgram) {
      throw new Error('Ticket NFT program not initialized');
    }

    return {
      mintTicket: async (
        eventId: string,
        ticketId: string,
        tier: BN,
        metadata: any,
        recipient: PublicKey
      ): Promise<TransactionResult> => {
        const mint = Keypair.generate();
        const [ticketMetadata] = PublicKey.findProgramAddressSync(
          [Buffer.from('ticket_metadata'), mint.publicKey.toBuffer()],
          this.ticketNftProgram!.programId
        );

        const recipientAta = await getAssociatedTokenAddress(
          mint.publicKey,
          recipient
        );

        // Create mint instruction
        const createMintIx = web3.SystemProgram.createAccount({
          fromPubkey: this.wallet!.publicKey!,
          newAccountPubkey: mint.publicKey,
          space: 82, // Mint account size
          lamports: await this.connection.getMinimumBalanceForRentExemption(82),
          programId: TOKEN_PROGRAM_ID,
        });

        // Initialize mint instruction
        const initMintIx = utils.token.createInitializeMintInstruction(
          mint.publicKey,
          0, // Decimals for NFT
          this.wallet!.publicKey!,
          null,
          TOKEN_PROGRAM_ID
        );

        // Create associated token account
        const createAtaIx = createAssociatedTokenAccountInstruction(
          this.wallet!.publicKey!,
          recipientAta,
          recipient,
          mint.publicKey
        );

        // Mint ticket instruction
        const mintTicketIx = await this.ticketNftProgram!.methods
          .mintTicket(ticketId, tier, metadata)
          .accounts({
            minter: this.wallet!.publicKey!,
            ticketMint: mint.publicKey,
            ticketMetadata,
            recipient,
            recipientTokenAccount: recipientAta,
            systemProgram: web3.SystemProgram.programId,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
          })
          .instruction();

        const tx = await this.buildTransaction(
          [createMintIx, initMintIx, createAtaIx, mintTicketIx],
          [mint]
        );

        return await this.sendTransaction(tx);
      },

      transferTicket: async (
        ticketMint: PublicKey,
        recipient: PublicKey
      ): Promise<TransactionResult> => {
        const senderAta = await getAssociatedTokenAddress(
          ticketMint,
          this.wallet!.publicKey!
        );

        const recipientAta = await getAssociatedTokenAddress(
          ticketMint,
          recipient
        );

        // Check if recipient ATA exists
        let createAtaIx: TransactionInstruction | null = null;
        try {
          await getAccount(this.connection, recipientAta);
        } catch (error) {
          if (error instanceof TokenAccountNotFoundError) {
            createAtaIx = createAssociatedTokenAccountInstruction(
              this.wallet!.publicKey!,
              recipientAta,
              recipient,
              ticketMint
            );
          }
        }

        const transferIx = utils.token.createTransferInstruction(
          senderAta,
          recipientAta,
          this.wallet!.publicKey!,
          1,
          [],
          TOKEN_PROGRAM_ID
        );

        const instructions = createAtaIx ? [createAtaIx, transferIx] : [transferIx];
        const tx = await this.buildTransaction(instructions);

        return await this.sendTransaction(tx);
      },

      getTicket: async (ticketMint: PublicKey): Promise<TicketData | null> => {
        const [ticketMetadata] = PublicKey.findProgramAddressSync(
          [Buffer.from('ticket_metadata'), ticketMint.toBuffer()],
          this.ticketNftProgram!.programId
        );

        return await this.getAccount<TicketData>(ticketMetadata, this.ticketNftProgram!);
      },

      getUserTickets: async (user: PublicKey): Promise<Array<{ mint: PublicKey; ticket: TicketData }>> => {
        // Get all token accounts for user
        const tokenAccounts = await this.connection.getParsedTokenAccountsByOwner(
          user,
          { programId: TOKEN_PROGRAM_ID }
        );

        const tickets: Array<{ mint: PublicKey; ticket: TicketData }> = [];

        for (const { pubkey, account } of tokenAccounts.value) {
          const parsedData = account.data as ParsedAccountData;
          const mintAddress = new PublicKey(parsedData.parsed.info.mint);
          
          // Check if this is a ticket NFT
          const ticket = await this.getTicket(mintAddress);
          if (ticket) {
            tickets.push({ mint: mintAddress, ticket });
          }
        }

        return tickets;
      },
    };
  }

  // Marketplace Program Methods
  public get marketplace() {
    if (!this.marketplaceProgram) {
      throw new Error('Marketplace program not initialized');
    }

    return {
      createListing: async (
        nftMint: PublicKey,
        price: BN | null,
        minBid: BN | null,
        duration: BN | null
      ): Promise<TransactionResult> => {
        const [listing] = PublicKey.findProgramAddressSync(
          [Buffer.from('listing'), nftMint.toBuffer()],
          this.marketplaceProgram!.programId
        );

        const [escrow] = PublicKey.findProgramAddressSync(
          [Buffer.from('escrow'), listing.toBuffer()],
          this.marketplaceProgram!.programId
        );

        const sellerTokenAccount = await getAssociatedTokenAddress(
          nftMint,
          this.wallet!.publicKey!
        );

        const escrowTokenAccount = await getAssociatedTokenAddress(
          nftMint,
          escrow,
          true
        );

        const ix = await this.marketplaceProgram!.methods
          .createListing(price, minBid, duration)
          .accounts({
            seller: this.wallet!.publicKey!,
            nftMint,
            listing,
            escrow,
            sellerTokenAccount,
            escrowTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
            associatedTokenProgram: ASSOCIATED_TOKEN_PROGRAM_ID,
            systemProgram: web3.SystemProgram.programId,
          })
          .instruction();

        const tx = await this.buildTransaction([ix]);
        return await this.sendTransaction(tx);
      },

      buyNow: async (
        nftMint: PublicKey,
        seller: PublicKey
      ): Promise<TransactionResult> => {
        const [listing] = PublicKey.findProgramAddressSync(
          [Buffer.from('listing'), nftMint.toBuffer()],
          this.marketplaceProgram!.programId
        );

        const [escrow] = PublicKey.findProgramAddressSync(
          [Buffer.from('escrow'), listing.toBuffer()],
          this.marketplaceProgram!.programId
        );

        const buyerTokenAccount = await getAssociatedTokenAddress(
          nftMint,
          this.wallet!.publicKey!
        );

        const sellerTokenAccount = await getAssociatedTokenAddress(
          nftMint,
          seller
        );

        const escrowTokenAccount = await getAssociatedTokenAddress(
          nftMint,
          escrow,
          true
        );

        const ix = await this.marketplaceProgram!.methods
          .buyNow()
          .accounts({
            buyer: this.wallet!.publicKey!,
            seller,
            listing,
            escrow,
            nftMint,
            sellerTokenAccount,
            buyerTokenAccount,
            escrowTokenAccount,
            tokenProgram: TOKEN_PROGRAM_ID,
            systemProgram: web3.SystemProgram.programId,
          })
          .instruction();

        const tx = await this.buildTransaction([ix]);
        return await this.sendTransaction(tx);
      },

      placeBid: async (
        nftMint: PublicKey,
        amount: BN
      ): Promise<TransactionResult> => {
        const [listing] = PublicKey.findProgramAddressSync(
          [Buffer.from('listing'), nftMint.toBuffer()],
          this.marketplaceProgram!.programId
        );

        const [bidVault] = PublicKey.findProgramAddressSync(
          [Buffer.from('bid_vault'), listing.toBuffer(), this.wallet!.publicKey!.toBuffer()],
          this.marketplaceProgram!.programId
        );

        const ix = await this.marketplaceProgram!.methods
          .placeBid(amount)
          .accounts({
            bidder: this.wallet!.publicKey!,
            listing,
            bidVault,
            systemProgram: web3.SystemProgram.programId,
          })
          .instruction();

        const tx = await this.buildTransaction([ix]);
        return await this.sendTransaction(tx);
      },

      getListing: async (nftMint: PublicKey): Promise<ListingData | null> => {
        const [listing] = PublicKey.findProgramAddressSync(
          [Buffer.from('listing'), nftMint.toBuffer()],
          this.marketplaceProgram!.programId
        );

        return await this.getAccount<ListingData>(listing, this.marketplaceProgram!);
      },

      getActiveListings: async (): Promise<Array<{ pubkey: PublicKey; account: ListingData }>> => {
        const filters = [
          {
            memcmp: {
              offset: 8 + 32 + 32, // Discriminator + seller + nftMint
              bytes: Buffer.from([0]).toString('base64'), // Status = Active
            },
          },
        ];

        return await this.getProgramAccounts<ListingData>(this.marketplaceProgram!, filters);
      },
    };
  }

  // Subscription Handling
  public subscribeToAccount<T>(
    address: PublicKey,
    program: Program<any>,
    callback: AccountChangeCallback<T>,
    commitment?: Commitment
  ): Subscription {
    const subscriptionId = this.connection.onAccountChange(
      address,
      (accountInfo) => {
        try {
          const decoded = program.coder.accounts.decode(
            this.getAccountType(program),
            accountInfo.data
          );
          callback(decoded as T, { slot: 0 }); // Context would come from the actual subscription
        } catch (error) {
          console.error('Failed to decode account data:', error);
        }
      },
      commitment || this.config.commitment
    );

    const id = this.subscriptionCounter++;
    this.subscriptions.set(id, subscriptionId);

    return {
      id,
      unsubscribe: () => {
        const subId = this.subscriptions.get(id);
        if (subId !== undefined) {
          this.connection.removeAccountChangeListener(subId);
          this.subscriptions.delete(id);
        }
      },
    };
  }

  public subscribeToLogs(
    address: PublicKey,
    callback: (logs: string[], error?: any) => void,
    commitment?: Commitment
  ): Subscription {
    const subscriptionId = this.connection.onLogs(
      address,
      (logs) => {
        if (logs.err) {
          callback(logs.logs, logs.err);
        } else {
          callback(logs.logs);
        }
      },
      commitment || this.config.commitment
    );

    const id = this.subscriptionCounter++;
    this.subscriptions.set(id, subscriptionId);

    return {
      id,
      unsubscribe: () => {
        const subId = this.subscriptions.get(id);
        if (subId !== undefined) {
          this.connection.removeOnLogsListener(subId);
          this.subscriptions.delete(id);
        }
      },
    };
  }

  public unsubscribeAll(): void {
    this.subscriptions.forEach((subId) => {
      this.connection.removeAccountChangeListener(subId);
    });
    this.subscriptions.clear();
  }

  // Utility Methods
  private getEndpoint(network: string): string {
    switch (network) {
      case 'mainnet-beta':
        return 'https://api.mainnet-beta.solana.com';
      case 'testnet':
        return 'https://api.testnet.solana.com';
      case 'devnet':
        return 'https://api.devnet.solana.com';
      case 'localnet':
        return 'http://localhost:8899';
      default:
        throw new Error(`Unknown network: ${network}`);
    }
  }

  private getProgramIds() {
    const defaultIds = {
      events: this.config.programIds?.events,
      ticketNft: this.config.programIds?.ticketNft,
      marketplace: this.config.programIds?.marketplace,
      contentAccess: this.config.programIds?.contentAccess,
      staking: this.config.programIds?.staking,
    };

    // In production, these would be the deployed program IDs
    // For now, using placeholders
    return {
      events: defaultIds.events || new PublicKey('11111111111111111111111111111111'),
      ticketNft: defaultIds.ticketNft || new PublicKey('11111111111111111111111111111111'),
      marketplace: defaultIds.marketplace || new PublicKey('11111111111111111111111111111111'),
      contentAccess: defaultIds.contentAccess || new PublicKey('11111111111111111111111111111111'),
      staking: defaultIds.staking || new PublicKey('11111111111111111111111111111111'),
    };
  }

  private getAccountType(program: Program<any>): string {
    // Map program to its main account type
    // This would be more sophisticated in a real implementation
    const programId = program.programId.toBase58();
    
    if (program === this.eventsProgram) return 'event';
    if (program === this.ticketNftProgram) return 'ticketMetadata';
    if (program === this.marketplaceProgram) return 'listing';
    if (program === this.contentAccessProgram) return 'contentRegistry';
    if (program === this.stakingProgram) return 'stakeAccount';
    
    return 'account';
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }

  // Error Handling
  public parseError(error: any): string {
    if (error.logs) {
      // Parse program logs for custom errors
      const customError = this.parseCustomError(error.logs);
      if (customError) return customError;
    }

    if (error.message) {
      return error.message;
    }

    return 'An unknown error occurred';
  }

  private parseCustomError(logs: string[]): string | null {
    // Look for custom program errors in logs
    const errorLog = logs.find(log => log.includes('Error:') || log.includes('failed'));
    
    if (errorLog) {
      // Extract error message
      const match = errorLog.match(/Error: (.*)/);
      if (match) return match[1];
    }

    return null;
  }

  // Balance and Token Utilities
  public async getBalance(address?: PublicKey): Promise<number> {
    const pubkey = address || this.wallet?.publicKey;
    if (!pubkey) throw new Error('No address provided');

    const balance = await this.connection.getBalance(pubkey);
    return balance / web3.LAMPORTS_PER_SOL;
  }

  public async getTokenBalance(mint: PublicKey, owner?: PublicKey): Promise<number> {
    const ownerPubkey = owner || this.wallet?.publicKey;
    if (!ownerPubkey) throw new Error('No owner address provided');

    const ata = await getAssociatedTokenAddress(mint, ownerPubkey);
    
    try {
      const account = await getAccount(this.connection, ata);
      return Number(account.amount);
    } catch (error) {
      if (error instanceof TokenAccountNotFoundError) {
        return 0;
      }
      throw error;
    }
  }

  public async requestAirdrop(amount: number, recipient?: PublicKey): Promise<TransactionSignature> {
    if (this.config.network !== 'devnet' && this.config.network !== 'testnet' && this.config.network !== 'localnet') {
      throw new Error('Airdrop only available on devnet, testnet, or localnet');
    }

    const pubkey = recipient || this.wallet?.publicKey;
    if (!pubkey) throw new Error('No recipient address');

    const signature = await this.connection.requestAirdrop(
      pubkey,
      amount * web3.LAMPORTS_PER_SOL
    );

    await this.confirmTransaction(signature);
    return signature;
  }

  // Health Check
  public async getHealth(): Promise<{
    connected: boolean;
    slot: number;
    blockTime: number | null;
    network: string;
  }> {
    try {
      const slot = await this.connection.getSlot();
      const blockTime = await this.connection.getBlockTime(slot);
      
      return {
        connected: true,
        slot,
        blockTime,
        network: this.config.network,
      };
    } catch (error) {
      return {
        connected: false,
        slot: 0,
        blockTime: null,
        network: this.config.network,
      };
    }
  }
}

// Export convenience function
export function createSolanaClient(config: SolanaClientConfig): SolanaClient {
  return new SolanaClient(config);
}

// Re-export useful types
export { PublicKey, Keypair, Transaction, BN } from '@solana/web3.js';
export { utils } from '@coral-xyz/anchor';
